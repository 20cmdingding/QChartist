<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Extraction-Modes">Extraction Modes</a></li>
      <li><a href="#Advice">Advice</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#CONSTRUCTOR">CONSTRUCTOR</a></li>
      <li><a href="#REGULAR-METHODS">REGULAR METHODS</a></li>
      <li><a href="#DEPRECATED-METHODS">DEPRECATED METHODS</a></li>
      <li><a href="#TABLE-METHODS">TABLE METHODS</a></li>
    </ul>
  </li>
  <li><a href="#NOTES-ON-TREE-EXTRACTION-MODE">NOTES ON TREE EXTRACTION MODE</a></li>
  <li><a href="#REQUIRES">REQUIRES</a></li>
  <li><a href="#OPTIONALLY-REQUIRES">OPTIONALLY REQUIRES</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>HTML::TableExtract - Perl module for extracting the content contained in tables within an HTML document, either as text or encoded element trees.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> <span class="comment"># Matched tables are returned as table objects; tables can be matched</span>
 <span class="comment"># using column headers, depth, count within a depth, table tag</span>
 <span class="comment"># attributes, or some combination of the four.</span>
 
 <span class="comment"># Example: Using column header information.</span>
 <span class="comment"># Assume an HTML document with tables that have "Date", "Price", and</span>
 <span class="comment"># "Cost" somewhere in a row. The columns beneath those headings are</span>
 <span class="comment"># what you want to extract. They will be returned in the same order as</span>
 <span class="comment"># you specified the headers since 'automap' is enabled by default.</span>
 
 <span class="keyword">use</span> <span class="variable">HTML::TableExtract</span><span class="operator">;</span>
 <span class="variable">$te</span> <span class="operator">=</span> <span class="variable">HTML::TableExtract</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">headers</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">qw(Date Price Cost)</span><span class="operator">]</span> <span class="operator">);</span>
 <span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="variable">$html_string</span><span class="operator">);</span>
 
 <span class="comment"># Examine all matching tables</span>
 <span class="keyword">foreach</span> <span class="variable">$ts</span> <span class="operator">(</span><span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">tables</span><span class="operator">)</span> <span class="operator">{</span>
   <span class="keyword">print</span> <span class="string">"Table ("</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">','</span><span class="operator">,</span> <span class="variable">$ts</span><span class="operator">-&gt;</span><span class="variable">coords</span><span class="operator">),</span> <span class="string">"):\n"</span><span class="operator">;</span>
   <span class="keyword">foreach</span> <span class="variable">$row</span> <span class="operator">(</span><span class="variable">$ts</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">','</span><span class="operator">,</span> <span class="variable">@$row</span><span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
   <span class="operator">}</span>
 <span class="operator">}</span>
 
 <span class="comment"># Shorthand...top level rows() method assumes the first table found in</span>
 <span class="comment"># the document if no arguments are supplied.</span>
 <span class="keyword">foreach</span> <span class="variable">$row</span> <span class="operator">(</span><span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">','</span><span class="operator">,</span> <span class="variable">@$row</span><span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
 <span class="operator">}</span>
 
 <span class="comment"># Example: Using depth and count information.</span>
 <span class="comment"># Every table in the document has a unique depth and count tuple, so</span>
 <span class="comment"># when both are specified it is a unique table. Depth and count both</span>
 <span class="comment"># begin with 0, so in this case we are looking for a table (depth 2)</span>
 <span class="comment"># within a table (depth 1) within a table (depth 0, which is the top</span>
 <span class="comment"># level HTML document). In addition, it must be the third (count 2)</span>
 <span class="comment"># such instance of a table at that depth.</span>
 
 <span class="variable">$te</span> <span class="operator">=</span> <span class="variable">HTML::TableExtract</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">depth</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="string">count</span> <span class="operator">=&gt;</span> <span class="number">2</span> <span class="operator">);</span>
 <span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">parse_file</span><span class="operator">(</span><span class="variable">$html_file</span><span class="operator">);</span>
 <span class="keyword">foreach</span> <span class="variable">$ts</span> <span class="operator">(</span><span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">tables</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Table found at "</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">','</span><span class="operator">,</span> <span class="variable">$ts</span><span class="operator">-&gt;</span><span class="variable">coords</span><span class="operator">),</span> <span class="string">":\n"</span><span class="operator">;</span>
    <span class="keyword">foreach</span> <span class="variable">$row</span> <span class="operator">(</span><span class="variable">$ts</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">)</span> <span class="operator">{</span>
       <span class="keyword">print</span> <span class="string">"   "</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">','</span><span class="operator">,</span> <span class="variable">@$row</span><span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
 <span class="operator">}</span>
 
 <span class="comment"># Example: Using table tag attributes.</span>
 <span class="comment"># If multiple attributes are specified, all must be present and equal</span>
 <span class="comment"># for match to occur.</span>
 
 <span class="variable">$te</span> <span class="operator">=</span> <span class="variable">HTML::TableExtract</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">attribs</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">border</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">}</span> <span class="operator">);</span>
 <span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="variable">$html_string</span><span class="operator">);</span>
 <span class="keyword">foreach</span> <span class="variable">$ts</span> <span class="operator">(</span><span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">tables</span><span class="operator">)</span> <span class="operator">{</span>
   <span class="keyword">print</span> <span class="string">"Table with border=1 found at "</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">','</span><span class="operator">,</span> <span class="variable">$ts</span><span class="operator">-&gt;</span><span class="variable">coords</span><span class="operator">),</span> <span class="string">":\n"</span><span class="operator">;</span>
   <span class="keyword">foreach</span> <span class="variable">$row</span> <span class="operator">(</span><span class="variable">$ts</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"   "</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">','</span><span class="operator">,</span> <span class="variable">@$row</span><span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
   <span class="operator">}</span>
 <span class="operator">}</span>
 
 <span class="comment"># Example: Extracting as an HTML::Element tree structure</span>
 <span class="comment"># Rather than extracting raw text, the html can be converted into a</span>
 <span class="comment"># tree of element objects. The HTML document is composed of</span>
 <span class="comment"># HTML::Element objects and the tables are HTML::ElementTable</span>
 <span class="comment"># structures. Using this, the contents of tables within a document can</span>
 <span class="comment"># be edited in-place.</span>
 
 <span class="keyword">use</span> <span class="variable">HTML::TableExtract</span> <span class="string">qw(tree)</span><span class="operator">;</span>
 <span class="variable">$te</span> <span class="operator">=</span> <span class="variable">HTML::TableExtract</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">headers</span> <span class="operator">=&gt;</span> <span class="string">qw(Fee Fie Foe Fum)</span> <span class="operator">);</span>
 <span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">parse_file</span><span class="operator">(</span><span class="variable">$html_file</span><span class="operator">);</span>
 <span class="variable">$table</span> <span class="operator">=</span> <span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">first_table_found</span><span class="operator">;</span>
 <span class="variable">$table_tree</span> <span class="operator">=</span> <span class="variable">$table</span><span class="operator">-&gt;</span><span class="variable">tree</span><span class="operator">;</span>
 <span class="variable">$table_tree</span><span class="operator">-&gt;</span><span class="variable">cell</span><span class="operator">(</span><span class="number">4</span><span class="operator">,</span><span class="number">4</span><span class="operator">)-&gt;</span><span class="variable">replace_content</span><span class="operator">(</span><span class="string">'Golden Goose'</span><span class="operator">);</span>
 <span class="variable">$table_html</span> <span class="operator">=</span> <span class="variable">$table_tree</span><span class="operator">-&gt;</span><span class="variable">as_HTML</span><span class="operator">;</span>
 <span class="variable">$table_text</span> <span class="operator">=</span> <span class="variable">$table_tree</span><span class="operator">-&gt;</span><span class="variable">as_text</span><span class="operator">;</span>
 <span class="variable">$document_tree</span> <span class="operator">=</span> <span class="variable">$te</span><span class="operator">-&gt;</span><span class="variable">tree</span><span class="operator">;</span>
 <span class="variable">$document_html</span> <span class="operator">=</span> <span class="variable">$document_tree</span><span class="operator">-&gt;</span><span class="variable">as_HTML</span><span class="operator">;</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>HTML::TableExtract is a subclass of HTML::Parser that serves to extract the information from tables of interest contained within an HTML document. The information from each extracted table is stored in table objects. Tables can be extracted as text, HTML, or HTML::ElementTable structures (for in-place editing or manipulation).</p>

<p>There are currently four constraints available to specify which tables you would like to extract from a document: <i>Headers</i>, <i>Depth</i>, <i>Count</i>, and <i>Attributes</i>.</p>

<p><i>Headers</i>, the most flexible and adaptive of the techniques, involves specifying text in an array that you expect to appear above the data in the tables of interest. Once all headers have been located in a row of that table, all further cells beneath the columns that matched your headers are extracted. All other columns are ignored: think of it as vertical slices through a table. In addition, TableExtract automatically rearranges each row in the same order as the headers you provided. If you would like to disable this, set <i>automap</i> to 0 during object creation, and instead rely on the column_map() method to find out the order in which the headers were found. Furthermore, TableExtract will automatically compensate for cell span issues so that columns are really the same columns as you would visually see in a browser. This behavior can be disabled by setting the <i>gridmap</i> parameter to 0. HTML is stripped from the entire textual content of a cell before header matches are attempted -- unless the <i>keep_html</i> parameter was enabled.</p>

<p><i>Depth</i> and <i>Count</i> are more specific ways to specify tables in relation to one another. <i>Depth</i> represents how deeply a table resides in other tables. The depth of a top-level table in the document is 0. A table within a top-level table has a depth of 1, and so on. Each depth can be thought of as a layer; tables sharing the same depth are on the same layer. Within each of these layers, <i>Count</i> represents the order in which a table was seen at that depth, starting with 0. Providing both a <i>depth</i> and a <i>count</i> will uniquely specify a table within a document.</p>

<p><i>Attributes</i> match based on the attributes of the html &lt;table&gt; tag, for example, border widths or background color.</p>

<p>Each of the <i>Headers</i>, <i>Depth</i>, <i>Count</i>, and <i>Attributes</i> specifications are cumulative in their effect on the overall extraction. For instance, if you specify only a <i>Depth</i>, then you get all tables at that depth (note that these could very well reside in separate higher- level tables throughout the document since depth extends across tables). If you specify only a <i>Count</i>, then the tables at that <i>Count</i> from all depths are returned (i.e., the <i>n</i>th occurrence of a table at each depth). If you only specify <i>Headers</i>, then you get all tables in the document containing those column headers. If you have specified multiple constraints of <i>Headers</i>, <i>Depth</i>, <i>Count</i>, and <i>Attributes</i>, then each constraint has veto power over whether a particular table is extracted.</p>

<p>If no <i>Headers</i>, <i>Depth</i>, <i>Count</i>, or <i>Attributes</i> are specified, then all tables match.</p>

<p>When extracting only text from tables, the text is decoded with HTML::Entities by default; this can be disabled by setting the <i>decode</i> parameter to 0.</p>

<h2 id="Extraction-Modes">Extraction Modes</h2>

<p>The default mode of extraction for HTML::TableExtract is raw text or HTML. In this mode, embedded tables are completely decoupled from one another. In this case, HTML::TableExtract is a subclass of HTML::Parser:</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">HTML::TableExtract</span><span class="operator">;</span>
</code></pre>

<p>Alternatively, tables can be extracted as HTML::ElementTable structures, which are in turn embedded in an HTML::Element tree representing the entire HTML document. Embedded tables are not decoupled from one another since this tree structure must be maintained. In this case, HTML::TableExtract is a subclass of HTML::TreeBuilder (itself a subclass of HTML:::Parser):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">HTML::TableExtract</span> <span class="string">qw(tree)</span><span class="operator">;</span>
</code></pre>

<p>In either case, the basic interface for HTML::TableExtract and the resulting table objects remains the same -- all that changes is what you can do with the resulting data.</p>

<p>HTML::TableExtract is a subclass of HTML::Parser, and as such inherits all of its basic methods such as <code>parse()</code> and <code>parse_file()</code>. During scans, <code>start()</code>, <code>end()</code>, and <code>text()</code> are utilized. Feel free to override them, but if you do not eventually invoke them in the SUPER class with some content, results are not guaranteed.</p>

<h2 id="Advice">Advice</h2>

<p>The main point of this module was to provide a flexible method of extracting tabular information from HTML documents without relying to heavily on the document layout. For that reason, I suggest using <i>Headers</i> whenever possible -- that way, you are anchoring your extraction on what the document is trying to communicate rather than some feature of the HTML comprising the document (other than the fact that the data is contained in a table).</p>

<h1 id="METHODS">METHODS</h1>

<p>The following are the top-level methods of the HTML::TableExtract object. Tables that have matched a query are actually returned as separate objects of type HTML::TableExtract::Table. These table objects have their own methods, documented further below.</p>

<h2 id="CONSTRUCTOR">CONSTRUCTOR</h2>

<dl>

<dt id="new">new()</dt>
<dd>

<p>Return a new HTML::TableExtract object. Valid attributes are:</p>

<dl>

<dt id="headers">headers</dt>
<dd>

<p>Passed as an array reference, headers specify strings of interest at the top of columns within targeted tables. They can be either strings or regular expressions (qr//). If they are strings, they will eventually be passed through a non-anchored, case-insensitive regular expression, so regexp special characters are allowed.</p>

<p>The table row containing the headers is <b>not</b> returned, unless <code>keep_headers</code> was specified or you are extracting into an element tree. In either case the header row can be accessed via the hrow() method from within the table object.</p>

<p>Columns that are not beneath one of the provided headers will be ignored unless <code>slice_columns</code> was set to 0. Columns will, by default, be rearranged into the same order as the headers you provide (see the <i>automap</i> parameter for more information) <i>unless</i> <code>slice_columns</code> is 0.</p>

<p>Additionally, by default columns are considered what you would see visually beneath that header when the table is rendered in a browser. See the <code>gridmap</code> parameter for more information.</p>

<p>HTML within a header is stripped before the match is attempted, unless the <code>keep_html</code> parameter was specified and <code>strip_html_on_match</code> is false.</p>

</dd>
<dt id="depth">depth</dt>
<dd>

<p>Specify how embedded in other tables your tables of interest should be. Top-level tables in the HTML document have a depth of 0, tables within top-level tables have a depth of 1, and so on.</p>

</dd>
<dt id="count">count</dt>
<dd>

<p>Specify which table within each depth you are interested in, beginning with 0.</p>

</dd>
<dt id="attribs">attribs</dt>
<dd>

<p>Passed as a hash reference, attribs specify attributes of interest within the HTML &lt;table&gt; tag itself.</p>

</dd>
<dt id="automap">automap</dt>
<dd>

<p>Automatically applies the ordering reported by column_map() to the rows returned by rows(). This only makes a difference if you have specified <i>Headers</i> and they turn out to be in a different order in the table than what you specified. Automap will rearrange the columns in the same order as the headers appear. To get the original ordering, you will need to take another slice of each row using column_map(). <i>automap</i> is enabled by default.</p>

</dd>
<dt id="slice_columns">slice_columns</dt>
<dd>

<p>Enabled by default, this option controls whether vertical slices are returned from under headers that match. When disabled, all columns of the matching table are retained, regardles of whether they had a matching header above them. Disabling this also disables <code>automap</code>.</p>

</dd>
<dt id="keep_headers">keep_headers</dt>
<dd>

<p>Disabled by default, and only applicable when header constraints have been specified, <code>keep_headers</code> will retain the matching header row as the first row of table data when enabled. This option has no effect if extracting into an element tree structure. In any case, the header row is accessible from the table method <code>hrow()</code>.</p>

</dd>
<dt id="gridmap">gridmap</dt>
<dd>

<p>Controls whether the table contents are returned as a grid or a tree. ROWSPAN and COLSPAN issues are compensated for, and columns really are columns. Empty phantom cells are created where they would have been obscured by ROWSPAN or COLSPAN settings. This really becomes an issue when extracting columns beneath headers. Enabled by default.</p>

</dd>
<dt id="subtables">subtables</dt>
<dd>

<p>Extract all tables embedded within matched tables.</p>

</dd>
<dt id="decode">decode</dt>
<dd>

<p>Automatically decode retrieved text with HTML::Entities::decode_entities(). Enabled by default. Has no effect if <code>keep_html</code> was specified or if extracting into an element tree structure.</p>

</dd>
<dt id="br_translate">br_translate</dt>
<dd>

<p>Translate &lt;br&gt; tags into newlines. Sometimes the remaining text can be hard to parse if the &lt;br&gt; tag is simply dropped. Enabled by default. Has no effect if <i>keep_html</i> is enabled or if extracting into an element tree structure.</p>

</dd>
<dt id="keep_html">keep_html</dt>
<dd>

<p>Return the raw HTML contained in the cell, rather than just the visible text. Embedded tables are <b>not</b> retained in the HTML extracted from a cell. Patterns for header matches must take into account HTML in the string if this option is enabled. This option has no effect if extracting into an elment tree structure.</p>

</dd>
<dt id="strip_html_on_match">strip_html_on_match</dt>
<dd>

<p>When <code>keep_html</code> is enabled, HTML is stripped by default during attempts at matching header strings (so if <code>strip_html_on_match</code> is not enabled and <code>keep_html</code> is, you would have to include potential HTML tags in the regexp for header matches). Stripped header tags are replaced with an empty string, e.g. &#39;hot d&lt;em&gt;og&lt;/em&gt;&#39; would become &#39;hot dog&#39; before attempting a match.</p>

</dd>
<dt id="error_handle">error_handle</dt>
<dd>

<p>Filehandle where error messages are printed. STDERR by default.</p>

</dd>
<dt id="debug">debug</dt>
<dd>

<p>Prints some debugging information to STDERR, more for higher values. If <code>error_handle</code> was provided, messages are printed there rather than STDERR.</p>

</dd>
</dl>

</dd>
</dl>

<h2 id="REGULAR-METHODS">REGULAR METHODS</h2>

<p>The following methods are invoked directly from an HTML::TableExtract object.</p>

<dl>

<dt id="depths">depths()</dt>
<dd>

<p>Returns all depths that contained matched tables in the document.</p>

</dd>
<dt id="counts-depth">counts($depth)</dt>
<dd>

<p>For a particular depth, returns all counts that contained matched tables.</p>

</dd>
<dt id="table-depth-count">table($depth, $count)</dt>
<dd>

<p>For a particular depth and count, return the table object for the table found, if any.</p>

</dd>
<dt id="tables">tables()</dt>
<dd>

<p>Return table objects for all tables that matched. Returns an empty list if no tables matched.</p>

</dd>
<dt id="first_table_found">first_table_found()</dt>
<dd>

<p>Return the table state object for the first table matched in the document. Returns undef if no tables were matched.</p>

</dd>
<dt id="current_table">current_table()</dt>
<dd>

<p>Returns the current table object while parsing the HTML. Only useful if you&#39;re messing around with overriding HTML::Parser methods.</p>

</dd>
<dt id="tree">tree()</dt>
<dd>

<p>If the module was invoked in tree extraction mode, returns a reference to the top node of the HTML::Element tree structure for the entire document (which includes, ultimately, all tables within the document).</p>

</dd>
<dt id="tables_report-show_content-col_sep">tables_report([$show_content, $col_sep])</dt>
<dd>

<p>Return a string summarizing extracted tables, along with their depth and count. Optionally takes a <code>$show_content</code> flag which will dump the extracted contents of each table as well with columns separated by <code>$col_sep</code>. Default <code>$col_sep</code> is &#39;:&#39;.</p>

</dd>
<dt id="tables_dump-show_content-col_sep">tables_dump([$show_content, $col_sep])</dt>
<dd>

<p>Same as <code>tables_report()</code> except dump the information to STDOUT.</p>

</dd>
<dt id="start">start</dt>
<dd>

</dd>
<dt id="end">end</dt>
<dd>

</dd>
<dt id="text">text</dt>
<dd>

<p>These are the hooks into HTML::Parser. If you want to subclass this module and have things work, you must at some point call these with content.</p>

</dd>
</dl>

<h2 id="DEPRECATED-METHODS">DEPRECATED METHODS</h2>

<p>Tables used to be called &#39;table states&#39;. Accordingly, the following methods still work but have been deprecated:</p>

<dl>

<dt id="table_state">table_state()</dt>
<dd>

<p>Is now table()</p>

</dd>
<dt id="table_states">table_states()</dt>
<dd>

<p>Is now tables()</p>

</dd>
<dt id="first_table_state_found">first_table_state_found()</dt>
<dd>

<p>Is now first_table_found()</p>

</dd>
</dl>

<h2 id="TABLE-METHODS">TABLE METHODS</h2>

<p>The following methods are invoked from an HTML::TableExtract::Table object, such as those returned from the <code>tables()</code> method.</p>

<dl>

<dt id="rows">rows()</dt>
<dd>

<p>Return all rows within a matched table. Each row returned is a reference to an array containing the text, HTML, or reference to the HTML::Element object of each cell depending the mode of extraction. Tables with rowspan or colspan attributes will have some cells containing undef. Returns a list or a reference to an array depending on context.</p>

</dd>
<dt id="columns">columns()</dt>
<dd>

<p>Return all columns within a matched table. Each column returned is a reference to an array containing the text, HTML, or reference to HTML::Element object of each cell depending on the mode of extraction. Tables with rowspan or colspan attributes will have some cells containing undef.</p>

</dd>
<dt id="row-row">row($row)</dt>
<dd>

<p>Return a particular row from within a matched table either as a list or an array reference, depending on context.</p>

</dd>
<dt id="column-col">column($col)</dt>
<dd>

<p>Return a particular column from within a matched table as a list or an array reference, depending on context.</p>

</dd>
<dt id="cell-row-col">cell($row,$col)</dt>
<dd>

<p>Return a particular item from within a matched table, whether it be the text, HTML, or reference to the HTML::Element object of that cell, depending on the mode of extraction. If the cell was covered due to rowspan or colspan effects, will return undef.</p>

</dd>
<dt id="space-row-col">space($row,$col)</dt>
<dd>

<p>The same as cell(), except in cases where the given coordinates were covered due to rowspan or colspan issues, in which case the content of the covering cell is returned rather than undef.</p>

</dd>
<dt id="depth1">depth()</dt>
<dd>

<p>Return the depth at which this table was found.</p>

</dd>
<dt id="count1">count()</dt>
<dd>

<p>Return the count for this table within the depth it was found.</p>

</dd>
<dt id="coords">coords()</dt>
<dd>

<p>Return depth and count in a list.</p>

</dd>
<dt id="tree1">tree()</dt>
<dd>

<p>If the module was invoked in tree extraction mode, this accessor provides a reference to the HTML::ElementTable structure encompassing the table.</p>

</dd>
<dt id="hrow">hrow()</dt>
<dd>

<p>Returns the header row as a list when headers were specified as a constraint. If <code>keep_headers</code> was specified initially, this is equivalent to the first row returned by the <code>rows()</code> method.</p>

</dd>
<dt id="column_map">column_map()</dt>
<dd>

<p>Return the order (via indices) in which the provided headers were found. These indices can be used as slices on rows to either order the rows in the same order as headers or restore the rows to their natural order, depending on whether the rows have been pre-adjusted using the <i>automap</i> parameter.</p>

</dd>
<dt id="lineage">lineage()</dt>
<dd>

<p>Returns the path of matched tables that led to matching this table. The path is a list of array refs containing depth, count, row, and column values for each ancestor table involved. Note that corresponding table objects will not exist for ancestral tables that did not match specified constraints.</p>

</dd>
</dl>

<h1 id="NOTES-ON-TREE-EXTRACTION-MODE">NOTES ON TREE EXTRACTION MODE</h1>

<p>As mentioned above, HTML::TableExtract can be invoked in &#39;tree&#39; mode where the resulting HTML and extracted tables are encoded in HTML::Element tree structures:</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">HTML::TableExtract</span> <span class="string">'tree'</span><span class="operator">;</span>
</code></pre>

<p>There are a number of things to take note of while using this mode. The entire HTML document is encoded into an HTML::Element tree. Each table is part of this structure, but nevertheless is tracked separately via an HTML::ElementTable structure, which is a specialized form of HTML::Element tree.</p>

<p>The HTML::ElementTable objects are accessible by invoking the tree() method from within each table object returned by HTML::TableExtract. The HTML::ElementTable objects have their own row(), col(), and cell() methods (among others). These are not to be confused with the row() and column() methods provided by the HTML::TableExtract::Table objects.</p>

<p>For example, the row() method from HTML::ElementTable will provide a reference to a &#39;glob&#39; of all the elements in that row. Actions (such as setting attributes) performed on that row reference will affect all elements within that row. On the other hand, the row() method from the HTML::TableExtract::Table object will return an array (either by reference or list, depending on context) of the contents of each cell within the row. In tree mode, the content is represented by individual references to each cell -- these are references to the same HTML::Element objects that reside in the HTML::Element tree.</p>

<p>The cell() methods provided in both cases will therefore return references to the same object. The exception to this is when a &#39;cell&#39; in the table grid was originally &#39;covered&#39; due to rowspan or colspan issues -- in this case the cell content will be undef. Likewise, the row() or column() methods from HTML::TableExtract::Table objects will return arrays potentially containing a mixture of object references and undefs. If you&#39;re going to be doing lots of manipulation of the table elements, it might be more efficient to access them via the methods provided by the HTML::ElementTable object instead. See <a>HTML::ElementTable</a> for more information on how to manipulate those objects.</p>

<p>An alternative to the cell() method in HTML::TableExtract::Table is the space() method. It is largely similar to cell(), except when given coordinates of a cell that was covered due to rowspan or colspan effects, it will return the contents of the cell that was covering that space rather than undef. So if, for example, cell (0,0) had a rowspan of 2 and colspan of 2, cell(1,1) would return undef and space(1,1) would return the same content as cell(0,0) or space(0,0).</p>

<h1 id="REQUIRES">REQUIRES</h1>

<p>HTML::Parser(3), HTML::Entities(3)</p>

<h1 id="OPTIONALLY-REQUIRES">OPTIONALLY REQUIRES</h1>

<p>HTML::TreeBuilder(3), HTML::ElementTable(3)</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Matthew P. Sisk, &lt;<i>sisk@mojotoad.com</i>&gt;</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 2000-2006 Matthew P. Sisk. All rights reserved. All wrongs revenged. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>HTML::Parser(3), HTML::TreeBuilder(3), HTML::ElementTable(3), perl(1).</p>


</body>

</html>


